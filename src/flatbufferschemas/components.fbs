// Copyright 2015 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

include "attributes.fbs";
include "bullet_def.fbs";
include "common.fbs";
include "events.fbs";

namespace fpl;

// Data definitions for all of components:
// ---------------------------------------------
table TransformDef {
  position:Vec3;
  scale:Vec3;
  orientation:Vec3;
  children:[EntityDef] (deprecated);
  child_ids:[string];
}

// How to allow selection of this entity, in the editor.
enum EditorSelectionOption:ubyte {
     Unspecified, // Not specified, so you don't overwrite a prototype value.
     Any,         // Allow this entity to be selected by any means.
     None,        // Never allow this entity to be selected.
     CycleOnly,   // Only allow this entity to be cycled through.
     PointerOnly, // Only allow this to be pointed at, not cycled through.
}

// When to render this entity: in the editor, not in the editor, etc.
enum EditorRenderOption:ubyte {
     Unspecified,  // Not specified, so you don't overwrite a prototype value.
     Always,       // Always render this entity.
     OnlyInEditor, // Only render when in the editor.
     NotInEditor,  // Only render when outside the editor.
}

table EditorDef {
  // Each entity has a unique entity ID. This includes entity prototypes.
  // If you don't specify the entity ID for your entity, it will be automatically
  // generated when needed.
  entity_id:string;

  // If this entity is based on a prototype, the prototype's entity ID goes here.
  prototype:string;

  // A human-readable comment to remember what this entity is for.
  comment:string;

  ignore_selection:byte = -1 (deprecated);

  // How to select this item in the editor (cycling thru, mouse pointer, etc.)
  selection_option:EditorSelectionOption = Unspecified;

  // Whether to render the object always, only in edit mode, etc.
  render_option:EditorRenderOption = Unspecified;
}

table TimeLimitDef {
  timelimit:float;
}

table RailDenizenDef {
  start_time:float;
  initial_playback_rate:float;
  on_new_lap:fpl.fpl_project.ActionDef;
  rail_file:string;
  rail_name:string;
  rail_offset:Vec3; // Additional offset from the rail position
  rail_orientation:Vec3; // Rotation to apply to the rail
  rail_scale:Vec3; // Scale to apply to the rail
  update_orientation:bool = true;
  enabled:bool = true;
}


enum RenderPass:ubyte {
  kOpaque,
  kAlpha,
  kCount
}

table RenderMeshDef {
  source_file:string;
  shader:string;
  ignore_culling:bool = false;
  render_pass: [RenderPass];
  hidden:bool = false;
}

table SoundDef {
  sound:string;
}

table PhysicsDef {
  shapes:[BulletShapeDef];
  kinematic:bool = false;
}

table PatronDef {
  on_collision:fpl.fpl_project.ActionDef;

  // Each time the raft makes a lap around the river, it's lap counter is
  // incremented.  Patrons will only stand up when the lap counter is in the
  // range [min_lap, max_lap].
  min_lap:int = -1;
  max_lap:int = -1;

  // If the raft is within the pop in radius, this patron will stand up.
  pop_in_radius:float;

  // If the raft is outside the pop out radius, this patron will fall down.
  pop_out_radius:float;
}

table PlayerDef {
  initial_direction:Vec3;
  on_fire:fpl.fpl_project.ActionDef;
}

table PlayerProjectileDef {
  on_collision:fpl.fpl_project.ActionDef;
}

table DigitDef {
  // Must list 10 meshes.
  digit_mesh_list:[string];
  divisor:int = -1;
  attrib:fpl.fpl_project.AttributeDef = Unspecified;
  shader:string;
  render_pass: [RenderPass];
}

// A spline node for a rail.
table RailNodeDef {
  // The nodes are put in ascending order to define the rail spline.
  // If you don't specify an ordering, the node entities will be given a
  // default ordering matching the order they were defined in the entity file.
  // This ordering will be preserved when you save out the entity list, even
  // if the order has changed on export.
  ordering:float;

  // The name of the rail we're part of. You'll query RailNodeComponent by
  // rail_name to get a list of rail points in the correct order.
  rail_name:string;

  // Total time for this rail. Only the first rail spline node (lowest ordering) for
  // each rail should have this set.
  total_time:float;

  // Reliable distance for this rail. Only the first rail spline node (lowest
  // ordering) for each rail should have this set.
  reliable_distance:float;
}

table RiverDef {
  // Which rail to base the river on?
  rail_name: string;
}

// No data, (never loaded from raw data) but we need it to be a thing so that it
// ends up in the enum.
table ListenerDef {}
table AttributesDef {}
table ScoreDef {}
table ServicesDef {}
table ShadowControllerDef {}

//-----------------------------------
// Data for defining the entities themselves:
// Union containing every possible component.
// Note: This will also be the order the components execute their updates in.
union ComponentDataUnion {
  ServicesDef,
  RailDenizenDef,
  ShadowControllerDef,
  PlayerDef,
  PatronDef,
  PlayerProjectileDef,
  PhysicsDef,
  TimeLimitDef,
  DigitDef,
  RenderMeshDef,
  ListenerDef,
  RiverDef,
  ScoreDef,
  SoundDef,
  AttributesDef,
  EditorDef,
  RailNodeDef,
  // The transform component should update after any other components that
  // might spawn or modify entities with transforms.
  TransformDef,
}

// Actual definition for each component.  Wrapped in a table because
// you can't make arrays of raw unions.
table ComponentDefInstance {
  data:ComponentDataUnion;
}

// An entity is just a list of what components it has, and what their
// starting values should be.
table EntityDef {
  component_list:[ComponentDefInstance];
}

// A list of entities.
table EntityListDef {
  entity_list:[EntityDef];
}

root_type EntityListDef;
